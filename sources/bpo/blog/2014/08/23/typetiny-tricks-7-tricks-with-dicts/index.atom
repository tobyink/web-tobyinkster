<?xml version="1.0" encoding="UTF-8"?>
<entry xmlns="http://www.w3.org/2005/Atom">
<title>Type::Tiny Tricks #7: Tricks with Dicts</title>
<link rel="alternate" type="text/html" href="http://blogs.perl.org/users/toby_inkster/2014/08/typetiny-tricks-7-tricks-with-dicts.html" />
<id>tag:blogs.perl.org,2014:/users/toby_inkster//1019.6326</id>
<published>2014-08-23T17:00:00</published>
<updated>2014-08-23T17:00:00</updated>
<summary> In Perl, hashes are typically used for two sorts of purposes: maps (where the hash key acts as an object identifier) and dictionaries (where the hash key acts like a field name). A quick illustration of what I mean...</summary>
<category term="tricks" scheme="http://www.sixapart.com/ns/types#category" />
<category term="Type-Tiny" scheme="http://www.sixapart.com/ns/types#category" />
<content type="html" xml:lang="en" xml:base="http://blogs.perl.org/users/toby_inkster/"><![CDATA[
                            <div>		<p>In Perl, hashes are typically used for two sorts of purposes: maps (where the hash key acts as an object identifier) and dictionaries (where the hash key acts like a field name). A quick illustration of what I mean by this:</p>
		<pre class="highlighting-perl"><span style="color:#060;font-style:italic" class="comment">   # Maps
</span>   <span style="color:#009;font-weight:bold" class="keyword">my</span> <span class="symbol" style="color:#333;background-color:#fcc">%ages</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="structure">(</span>
      <span class="word">alice</span>   <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span style="color:#39C" class="number">24</span><span style="color:#000;font-weight:bold" class="operator">,</span>
      <span class="word">bob</span>     <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span style="color:#39C" class="number">25</span><span class="operator" style="color:#000;font-weight:bold">,</span>
      <span class="word">carol</span>   <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="number" style="color:#39C">31</span><span class="operator" style="color:#000;font-weight:bold">,</span>
   <span class="structure">);</span>
   <span style="color:#009;font-weight:bold" class="keyword">my</span> <span style="color:#333;background-color:#fcc" class="symbol">%email</span> <span style="color:#000;font-weight:bold" class="operator">=</span> <span class="structure">(</span>
      <span class="word">alice</span>   <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span style="color:#909" class="double">"alice@example.net"</span><span class="operator" style="color:#000;font-weight:bold">,</span>
      <span class="word">bob</span>     <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="double" style="color:#909">"robert.smith@example.com"</span><span class="operator" style="color:#000;font-weight:bold">,</span>
      <span class="word">carol</span>   <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span style="color:#909" class="double">"c_jones@example.org"</span><span style="color:#000;font-weight:bold" class="operator">,</span>
   <span class="structure">);</span>
   
<span class="comment" style="color:#060;font-style:italic">   # Dictionaries
</span>   <span class="keyword" style="color:#009;font-weight:bold">my</span> <span style="color:#333;background-color:#fcc" class="symbol">%alice</span> <span style="color:#000;font-weight:bold" class="operator">=</span> <span class="structure">(</span> <span class="word">age</span> <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="number" style="color:#39C">24</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">email</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="double" style="color:#909">"alice@example.net"</span> <span class="structure">);</span>
   <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="symbol" style="color:#333;background-color:#fcc">%bob</span>   <span style="color:#000;font-weight:bold" class="operator">=</span> <span class="structure">(</span> <span class="word">age</span> <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="number" style="color:#39C">25</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">email</span> <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="double" style="color:#909">"robert.smith@example.com"</span> <span class="structure">);</span>
   <span style="color:#009;font-weight:bold" class="keyword">my</span> <span style="color:#333;background-color:#fcc" class="symbol">%carol</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="structure">(</span> <span class="word">age</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span style="color:#39C" class="number">32</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">email</span> <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="double" style="color:#909">"c_jones@example.org"</span> <span class="structure">);</span></pre>
		<p>These are two different styles of using hashes. Sometimes one is useful, and sometimes the other is. Sometimes neither is better and your choice of one over the other is fairly arbitrary.</p>
		<p><a href="https://metacpan.org/pod/Types%3A%3AStandard" class="podlinkpod">Types::Standard</a> contains a type constraint called <code class="prettyprint">Map</code> which is useful for validating references to the first kind of hash. (I copied the idea from <a href="https://metacpan.org/pod/MooseX%3A%3ATypes%3A%3AStructured" class="podlinkpod">MooseX::Types::Structured</a>.) But today I'm mainly going to talk about another type constraint: <code class="prettyprint">Dict</code>. (Yeah, I copied that one too.)</p></div>

                            		<p>Let's say you have a value which is supposed to be hashref pointing to a hash along the lines of <code class="prettyprint">%alice</code> or <code class="prettyprint">%bob</code> above. We can define a type constraint like this:</p>
		<pre class="highlighting-perl">   <span style="color:#009;font-weight:bold" class="keyword">use</span> <span class="word">Types::Standard</span> <span class="words" style="color:#333;background-color:#ffc">qw( Dict Int )</span><span class="structure">;</span>
   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Type::EmailAddress</span> <span style="color:#333;background-color:#ffc" class="words">qw( EmailAddress )</span><span class="structure">;</span>
   
   <span style="color:#009;font-weight:bold" class="keyword">my</span> <span class="symbol" style="color:#333;background-color:#fcc">$type</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">Dict</span><span class="structure">[</span> <span class="word">age</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">Int</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">email</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">EmailAddress</span> <span class="structure">];</span></pre>
		<p>And we can check a hashref against the type constraint like this:</p>
		<pre class="highlighting-perl">   <span style="color:#333;background-color:#fcc" class="symbol">$type</span><span style="color:#000;font-weight:bold" class="operator">-&gt;</span><span class="word">check</span><span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$href</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">or</span> <span class="word">die</span> <span class="double" style="color:#909">"Argghh!!"</span><span class="structure">;</span></pre>
		<p>Or maybe you can't think of a funny message to die with, so instead you can rely on Type::Tiny to generate one for you.</p>
		<pre class="highlighting-perl">   <span style="color:#333;background-color:#fcc" class="symbol">$type</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">assert_valid</span><span class="structure">(</span><span style="color:#333;background-color:#fcc" class="symbol">$href</span><span class="structure">);</span>   <span class="comment" style="color:#060;font-style:italic"># dies if invalid</span></pre>
		<p>Now that's useful, but perhaps sometimes we don't know a person's age. In this case, we can make it optional:</p>
		<pre class="highlighting-perl">   <span class="symbol" style="color:#333;background-color:#fcc">$type</span> <span style="color:#000;font-weight:bold" class="operator">=</span> <span class="word">Dict</span><span class="structure">[</span> <span class="word">age</span> <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="word">Optional</span><span class="structure">[</span><span class="word">Int</span><span class="structure">]</span><span style="color:#000;font-weight:bold" class="operator">,</span> <span class="word">email</span> <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="word">EmailAddress</span> <span class="structure">];</span></pre>
		<p>A hashref with a missing <code class="prettyprint">age</code> key will now pass the type constraint, though a hashref with an explicit <code class="prettyprint">undef</code> in the age slot will fail. Maybe you want to indicate an unknown age with an explicit <code class="prettyprint">undef</code> though. So then you'd use:</p>
		<pre class="highlighting-perl">   <span style="color:#333;background-color:#fcc" class="symbol">$type</span> <span style="color:#000;font-weight:bold" class="operator">=</span> <span class="word">Dict</span><span class="structure">[</span> <span class="word">age</span> <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="word">Int</span><span class="operator" style="color:#000;font-weight:bold">|</span><span class="word">Undef</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">email</span> <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="word">EmailAddress</span> <span class="structure">];</span></pre>
		<p>Or perhaps either way is OK. If you don't know the age, sometime you'll provide an explicit <code class="prettyprint">undef</code>, and sometimes you'll just leave the <code class="prettyprint">age</code> key out of the hashref. OK, that's fine too...</p>
		<pre class="highlighting-perl">   <span style="color:#333;background-color:#fcc" class="symbol">$type</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">Dict</span><span class="structure">[</span> <span class="word">age</span> <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="word">Optional</span><span class="structure">[</span><span class="word">Int</span><span class="operator" style="color:#000;font-weight:bold">|</span><span class="word">Undef</span><span class="structure">]</span><span style="color:#000;font-weight:bold" class="operator">,</span> <span class="word">email</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">EmailAddress</span> <span class="structure">];</span></pre>
		<p>Here's our last trick. Currently, the following hashref will fail the type constraint check:</p>
		<pre class="highlighting-perl">   <span class="symbol" style="color:#333;background-color:#fcc">$href</span> <span style="color:#000;font-weight:bold" class="operator">=</span> <span class="structure">{</span>
      <span class="word">age</span>        <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="number" style="color:#39C">30</span><span style="color:#000;font-weight:bold" class="operator">,</span>
      <span class="word">email</span>      <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span style="color:#909" class="double">"dave@example.net"</span><span style="color:#000;font-weight:bold" class="operator">,</span>
      <span class="word">x_website</span>  <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="double" style="color:#909">"http://example.net/~dave/"</span><span class="operator" style="color:#000;font-weight:bold">,</span>
   <span class="structure">};</span></pre>
		<p>Extra keys are not allowed. This limits the extensibility of our code. But if you read my previous article about tricks with tuples, then you might have an idea about the solution.</p>
		<pre class="highlighting-perl">   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Types::Standard</span> <span style="color:#333;background-color:#ffc" class="words">qw( Dict Optional Int slurpy Map StrMatch Str )</span><span class="structure">;</span>
   <span style="color:#009;font-weight:bold" class="keyword">use</span> <span class="word">Type::EmailAddress</span> <span class="words" style="color:#333;background-color:#ffc">qw( EmailAddress )</span><span class="structure">;</span>
   
   <span class="keyword" style="color:#009;font-weight:bold">my</span> <span style="color:#333;background-color:#fcc" class="symbol">$type</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">Dict</span><span class="structure">[</span>
      <span class="word">age</span>   <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">Optional</span><span class="structure">[</span><span class="word">Int</span><span class="structure">]</span><span class="operator" style="color:#000;font-weight:bold">,</span>
      <span class="word">email</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">EmailAddress</span><span class="operator" style="color:#000;font-weight:bold">,</span>
      <span class="word">slurpy</span> <span class="word">Map</span><span class="structure">[</span><span class="word">StrMatch</span><span class="structure">[</span><span class="regexp">qr/^x_/</span><span class="structure">]</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">Str</span><span class="structure">]</span><span class="operator" style="color:#000;font-weight:bold">,</span>
   <span class="structure">];</span></pre>
		<p>OK, this probably requires some explanation. This type constraint will validate <code class="prettyprint">age</code> and <code class="prettyprint">email</code> as usual, but then if the hashref contains any unrecognized fields, these will be slurped up into a temporary hashref (let's call it <code class="prettyprint">\%tmp</code>). It then validates <code class="prettyprint">\%tmp</code> against the <code class="prettyprint">Map[StrMatch[qr/^x_/], Str]</code> type constraint.</p>
		<p>What is <code class="prettyprint">Map[StrMatch[qr/^x_/], Str]</code>? It's a hashref where all keys are strings matching <code class="prettyprint">qr/^x_/</code>, and all values are strings. So our hashref of data about Dave should pass OK.</p>
		<p>Pop quiz! What does this mean?</p>
		<pre class="highlighting-perl">   <span class="symbol" style="color:#333;background-color:#fcc">$type</span> <span style="color:#000;font-weight:bold" class="operator">=</span> <span class="word">Dict</span><span class="structure">[</span>
      <span class="word">age</span>   <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="word">Optional</span><span class="structure">[</span><span class="word">Int</span><span class="structure">]</span><span class="operator" style="color:#000;font-weight:bold">,</span>
      <span class="word">email</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">EmailAddress</span><span style="color:#000;font-weight:bold" class="operator">,</span>
      <span class="word">slurpy</span> <span class="word">Any</span><span style="color:#000;font-weight:bold" class="operator">,</span>
   <span class="structure">];</span></pre>
		<p>Answer: it validates the <code class="prettyprint">age</code> and <code class="prettyprint">email</code> as usual, and slurps any remaining keys into <code class="prettyprint">\%tmp</code>, and validates that against the <code class="prettyprint">Any</code> type constraint.</p>
		<p>(In reality this is more optimized. The <code class="prettyprint">Any</code> type constraint <i>always</i> passes, no matter what value you check. So Type::Tiny is smart enough to never actually create that <code class="prettyprint">\%tmp</code> hash.)</p>
		<p>The combination of <code class="prettyprint">Dict</code>, <code class="prettyprint">Tuple</code>, <code class="prettyprint">Map</code>, <code class="prettyprint">HashRef</code>, and <code class="prettyprint">ArrayRef</code> allows for some very precise deep validation of values, but remember not to get carried away. A simple:</p>
		<pre class="highlighting-perl">   <span class="word">isa</span> <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="word">HashRef</span></pre>
		<p>... will run much faster if you're not in need of all that fancy validation!</p>

                        ]]></content>
</entry>
