<?xml version="1.0" encoding="UTF-8"?>
<entry xmlns="http://www.w3.org/2005/Atom">
<title>Type::Tiny Tricks #6: Tricks with Tuples</title>
<link rel="alternate" type="text/html" href="http://blogs.perl.org/users/toby_inkster/2014/08/typetiny-tricks-6-tricks-with-tuples.html" />
<id>tag:blogs.perl.org,2014:/users/toby_inkster//1019.6325</id>
<published>2014-08-22T18:00:00</published>
<updated>2014-08-22T18:00:00</updated>
<summary> Let&#x26;apos;s say you want an attribute to accept a pair of numbers - perhaps a geographic co-ordinates [ 50.873, -0.002 ]. You could constrain the attribute as ArrayRef[Num], but that would accept an arrayref containing a single number, or...</summary>
<category term="tricks" scheme="http://www.sixapart.com/ns/types#category" />
<category term="Type-Tiny" scheme="http://www.sixapart.com/ns/types#category" />
<content type="html" xml:lang="en" xml:base="http://blogs.perl.org/users/toby_inkster/"><![CDATA[
                            <div>		<p>Let's say you want an attribute to accept a pair of numbers - perhaps a geographic co-ordinates <code class="prettyprint">[ 50.873, -0.002 ]</code>. You could constrain the attribute as <code class="prettyprint">ArrayRef[Num]</code>, but that would accept an arrayref containing a single number, or eight numbers, or even a reference to an empty array.</p>
		<p>With the <code class="prettyprint">Tuple</code> type constraint, you can be more exact in expressing which values are acceptable:</p>
		<pre class="highlighting-perl">   <span class="word">isa</span>  <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="word">Tuple</span><span class="structure">[</span> <span class="word">Num</span><span style="color:#000;font-weight:bold" class="operator">,</span> <span class="word">Num</span> <span class="structure">]</span></pre></div>

                            		<p>Now let's say we want to optionally accept a third number; an altitude, in metres, which should be an integer. If the altitude is unknown, then it may be omitted. That's possible too:</p>
		<pre class="highlighting-perl">   <span class="word">isa</span>  <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="word">Tuple</span><span class="structure">[</span> <span class="word">Num</span><span style="color:#000;font-weight:bold" class="operator">,</span> <span class="word">Num</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">Optional</span><span class="structure">[</span><span class="word">Int</span><span class="structure">]</span> <span class="structure">]</span></pre>
		<p>OK, let's forget altitude now, and assume we want to accept a pair of co-ordinates followed by zero or more strings indicating a label for the location:</p>
		<pre class="highlighting-perl">   <span class="structure">[</span> <span class="float">50.873</span><span style="color:#000;font-weight:bold" class="operator">,</span> <span class="float">-0.002</span><span style="color:#000;font-weight:bold" class="operator">,</span> <span style="color:#909" class="double">"Lewes"</span><span style="color:#000;font-weight:bold" class="operator">,</span> <span style="color:#909" class="double">"East Sussex"</span><span style="color:#000;font-weight:bold" class="operator">,</span> <span style="color:#909" class="double">"United Kingdom"</span> <span class="structure">]</span></pre>
		<p>The list of strings is variable length, but Tuples can cope with that too:</p>
		<pre class="highlighting-perl">   <span class="word">isa</span>  <span style="color:#000;font-weight:bold" class="operator">=&gt;</span> <span class="word">Tuple</span><span class="structure">[</span> <span class="word">Num</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">Num</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">slurpy</span> <span class="word">ArrayRef</span><span class="structure">[</span><span class="word">Str</span><span class="structure">]</span> <span class="structure">]</span></pre>
		<p>The <code class="prettyprint">slurpy</code> part conceptually slurps the remaining items of the arrayref into a new temporary array, and validates that against the <code class="prettyprint">ArrayRef[Str]</code> constraint. Checking a value against this constraint is roughly equivalent to:</p>
		<pre class="highlighting-perl">   <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$temp1</span><span style="color:#000;font-weight:bold" class="operator">,</span> <span style="color:#333;background-color:#fcc" class="symbol">$temp2</span><span style="color:#000;font-weight:bold" class="operator">,</span> <span style="color:#333;background-color:#fcc" class="symbol">@slurpy</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span style="color:#f00;font-weight:bold" class="cast">@</span><span style="color:#333;background-color:#fcc" class="symbol">$value</span><span class="structure">;</span>
   <span class="word">Num</span><span style="color:#000;font-weight:bold" class="operator">-&gt;</span><span class="word">assert_valid</span><span class="structure">(</span><span style="color:#333;background-color:#fcc" class="symbol">$temp1</span><span class="structure">);</span>
   <span class="word">Num</span><span style="color:#000;font-weight:bold" class="operator">-&gt;</span><span class="word">assert_valid</span><span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$temp2</span><span class="structure">);</span>
   <span class="word">ArrayRef</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">of</span><span class="structure">(</span><span class="word">Str</span><span class="structure">)</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">assert_valid</span><span class="structure">(</span><span style="color:#f00;font-weight:bold" class="cast">\</span><span class="symbol" style="color:#333;background-color:#fcc">@slurpy</span><span class="structure">);</span></pre>
		<p>As well as validating arrayrefs containing a mixture of different datatypes, <code class="prettyprint">Tuple</code> can be used to validate more homogenous arrays. For example <code class="prettyprint">Tuple[Int, slurpy ArrayRef[Int]]</code> is equivalent to <code class="prettyprint">ArrayRef[Int]</code> except that it requires at least one item in the array.</p>
		<p><code class="prettyprint">ArrayRef[Int] &amp; Tuple[Any, slurpy Any]</code> does the same, but might be more efficient because <code class="prettyprint">Any</code> is very optimized.</p>
		<p>What about if you want to accept an arrayref of integers which is typically many thousands of integers long. You might like to save time by only validating that the first five items in the arrayref are integers. The rest we'll accept on trust:</p>
		<pre class="highlighting-perl">   <span class="word">Tuple</span><span class="structure">[</span> <span class="structure">(</span><span class="word">Optional</span><span class="structure">[</span><span class="word">Int</span><span class="structure">])</span> <span class="operator" style="color:#000;font-weight:bold">x</span> <span class="number" style="color:#39C">5</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">slurpy</span> <span class="word">Any</span> <span class="structure">]</span></pre>
		<p>The <code class="prettyprint">Tuple</code> type constraint is useful for all kinds of things. It would be useful to have an equivalently flexible constraint for hashrefs, wouldn't it? We'll cover that in the next tip.</p>

                        ]]></content>
</entry>
