<?xml version="1.0" encoding="UTF-8"?>
<entry xmlns="http://www.w3.org/2005/Atom">
    <title>Type::Tiny - not just for attributes</title>
    <link rel="alternate" type="text/html" href="http://blogs.perl.org/users/toby_inkster/2013/05/typetiny---not-just-for-attributes.html"/>
    <id>tag:blogs.perl.org,2013:/users/toby_inkster//1019.4650</id>

    <published>2013-05-06T13:15:29Z</published>
    <updated>2013-05-06T13:22:37Z</updated>

    <summary> OK, so I've gotten back from the May Day parade, had some lunch, and now it's time for me to write about Type::Tiny some more......</summary>
    <author>
        <name>Toby Inkster</name>
        <uri>http://tobyinkster.co.uk/</uri>
    </author>
    
    <category term="moo" label="Moo" scheme="http://www.sixapart.com/ns/types#tag"/>
    <category term="moose" label="Moose" scheme="http://www.sixapart.com/ns/types#tag"/>
    <category term="typetiny" label="Type-Tiny" scheme="http://www.sixapart.com/ns/types#tag"/>
    
    <content type="html" xml:lang="en" xml:base="http://blogs.perl.org/users/toby_inkster/">
        <![CDATA[		<p>OK, so I've gotten back from the May Day parade, had some lunch, and now it's time for me to write about Type::Tiny some more...</p>
]]>
        <![CDATA[		<p><a class="podlinkpod" href="https://metacpan.org/module/Type%3A%3ATiny">Type::Tiny</a> is a zero-dependency implementation of type constraints that can be used with <a class="podlinkpod" href="https://metacpan.org/module/Moose">Moose</a>, <a class="podlinkpod" href="https://metacpan.org/module/Mouse">Mouse</a> and <a class="podlinkpod" href="https://metacpan.org/module/Moo">Moo</a> alike. (No more need to build separate type libraries for each of them!)</p>
		<p>A typical usage might be:</p>
		<pre class="highlighting-perl">        <span class="keyword" style="color:#009;font-weight:bold">package</span> <span class="word">Person</span><span class="structure">;</span>
        <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Moose</span><span class="structure">;</span>
        <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Types::Standard</span> <span class="word">-types</span><span class="structure">;</span>
        
        <span class="word">has</span> <span class="word">name</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="structure">(</span><span class="word">is</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="double" style="color:#909">"ro"</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">isa</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">Str</span><span class="structure">);</span>
        <span class="word">has</span> <span class="word">age</span>  <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="structure">(</span><span class="word">is</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="double" style="color:#909">"ro"</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">isa</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">Int</span><span class="structure">);</span></pre>
		<p>But why stop there? Type constraints can also be useful for other purposes such as unit testing (e.g. check your function returns an <code>Int</code>) and validation. It's validation we'll look at today; specifically validating sub parameters.</p>
		<p>Let's take a look at a simple function which takes a hash, and returns a copy of that hash, but adding a number to certain keys.</p>
		<pre class="highlighting-perl">        <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="word">hash_add</span> <span class="structure">{</span>
                <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$number</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$hash</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$keys</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">;</span>
                <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="symbol" style="color:#333;background-color:#fcc">%clone</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="cast" style="color:#f00;font-weight:bold">%</span><span class="symbol" style="color:#333;background-color:#fcc">$hash</span><span class="structure">;</span>
                <span class="symbol" style="color:#333;background-color:#fcc">$clone</span><span class="structure">{</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">}</span> <span class="operator" style="color:#000;font-weight:bold">+=</span> <span class="symbol" style="color:#333;background-color:#fcc">$number</span> <span class="word">for</span> <span class="cast" style="color:#f00;font-weight:bold">@</span><span class="symbol" style="color:#333;background-color:#fcc">$keys</span><span class="structure">;</span>
                <span class="keyword" style="color:#009;font-weight:bold">return</span> <span class="cast" style="color:#f00;font-weight:bold">\</span><span class="symbol" style="color:#333;background-color:#fcc">%clone</span><span class="structure">;</span>
        <span class="structure">}</span>
        
        <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="symbol" style="color:#333;background-color:#fcc">$r</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">hash_add</span><span class="structure">(</span><span class="number" style="color:#39C">7</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="structure">{</span> <span class="word">foo</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="number" style="color:#39C">1</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">bar</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="number" style="color:#39C">2</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">baz</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="number" style="color:#39C">3</span> <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="structure">[</span><span class="words" style="color:#333;background-color:#ffc">qw/foo bar/</span><span class="structure">]);</span>
<span class="comment" style="color:#060;font-style:italic">        ## =&gt; { foo =&gt; 8, bar =&gt; 9, baz =&gt; 3 }</span></pre>
		<p>Why would you want a function like this? I admit it's somewhat contrived, but it includes three different types (a number, a hashref and an arrayref), so is a good illustration of the principles involved.</p>
		<p>Here's how you'd add parameter validation using the venerable <a class="podlinkpod" href="https://metacpan.org/module/Params%3A%3AValidate">Params::Validate</a>:</p>
		<pre class="highlighting-perl">        <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Params::Validate</span> <span class="words" style="color:#333;background-color:#ffc">qw(:all)</span><span class="structure">;</span>
        <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Scalar::Util</span> <span class="words" style="color:#333;background-color:#ffc">qw(looks_like_number)</span><span class="structure">;</span>
        
        <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="word">hash_add</span> <span class="structure">{</span>
                <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$number</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$hash</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$keys</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">validate_pos</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">@_</span><span class="operator" style="color:#000;font-weight:bold">,</span>
                        <span class="structure">{</span>
                                <span class="word">type</span>      <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">SCALAR</span><span class="operator" style="color:#000;font-weight:bold">,</span>
                                <span class="word">callbacks</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="structure">{</span> <span class="word">numeric</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="structure">{</span> <span class="word">looks_like_number</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">[</span><span class="number" style="color:#39C">0</span><span class="structure">])</span> <span class="structure">}</span> <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span>
                        <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span>
                        <span class="structure">{</span> <span class="word">type</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">HASHREF</span> <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span>
                        <span class="structure">{</span> <span class="word">type</span> <span class="operator" style="color:#000;font-weight:bold">=&gt;</span> <span class="word">ARRAYREF</span> <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span>
                <span class="structure">);</span>
                <span class="operator" style="color:#000;font-weight:bold">...</span><span class="structure">;</span>
        <span class="structure">}</span></pre>
		<p>Using <a class="podlinkpod" href="https://metacpan.org/module/Type%3A%3AParams">Type::Params</a> which comes bundled with Type::Tiny is somewhat more elegant for this simple case (which is not to say that it is always so!):</p>
		<pre class="highlighting-perl">        <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Type::Params</span> <span class="words" style="color:#333;background-color:#ffc">qw(compile)</span><span class="structure">;</span>
        <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Types::Standard</span> <span class="word">-types</span><span class="structure">;</span>
        
        <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="word">hash_add</span> <span class="structure">{</span>
                <span class="word">state</span> <span class="symbol" style="color:#333;background-color:#fcc">$check</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">compile</span><span class="structure">(</span><span class="word">Num</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">HashRef</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">ArrayRef</span><span class="structure">);</span>
                <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$number</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$hash</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$keys</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="symbol" style="color:#333;background-color:#fcc">$check</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">);</span>
                <span class="operator" style="color:#000;font-weight:bold">...</span><span class="structure">;</span>
        <span class="structure">}</span></pre>
		<p>But surely this elegance comes at some cost? After all; Params::Validate is fast! It has an XS backend that blows the socks off many of its rivals (<a class="podlinkpod" href="https://metacpan.org/module/Data%3A%3AValidator">Data::Validator</a>, etc).</p>
		<p>Well, you'd be wrong! According to my benchmarks, Type::Params is more than twice as fast as Params::Validate's XS backend. (And more than six times as fast as Params::Validate's pure Perl backend.) Don't believe me? <a class="podlinkurl" href="https://gist.github.com/tobyink/5501883">Here is my benchmark script</a>.</p>
		<p>In fact, Type::Params is so fast, and building up constraints is so simple, that you might find yourself wanting to make your validation more brutal, just because you can! Let's make sure that all the values in the hashref are really numbers; and that all the elements of the arrayref are strings:</p>
		<pre class="highlighting-perl">        <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="word">hash_add</span> <span class="structure">{</span>
                <span class="word">state</span> <span class="symbol" style="color:#333;background-color:#fcc">$check</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">compile</span><span class="structure">(</span><span class="word">Num</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">HashRef</span><span class="structure">[</span><span class="word">Num</span><span class="structure">]</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">ArrayRef</span><span class="structure">[</span><span class="word">Str</span><span class="structure">]);</span>
                <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$number</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$hash</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$keys</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="symbol" style="color:#333;background-color:#fcc">$check</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">);</span>
                <span class="operator" style="color:#000;font-weight:bold">...</span><span class="structure">;</span>
        <span class="structure">}</span></pre>
		<p>OK, so this is slower than our earlier parameter check, but not unacceptably slow; and still faster than the <i>less strict</i> Params::Validate check.</p>
		<h2><span id="How??">How??</span></h2>
		<p>So, how does Type::Params achieve its speed? Super optimized assembly language programming linked to via XS? Nothing of the sort; it's actually pure Perl.</p>
		<p>It's fast because the first time you call <code>hash_add</code>, it generates a long string of Perl code that will be used to validate your parameters, then passes that through <code>eval</code> to create a custom validation coderef for your sub. (Just a glimpse of the mess of source code within that coderef is enough to give many people nightmares!) This first call is actually far slower than Params::Validate - about 10 times slower than the PP backend, but that's still under a millisecond on most modern computers.</p>
		<p>Subsequent calls to the same function reuse that coderef, so go much faster.</p>
		<p>The break-even point for using this trick seems to be around 20 sub calls. If your sub is going to be called more than 20 times, compiling that coderef is a sound investment. (If your sub is going to be called fewer times, then you probably don't need to worry too much about micro-optimizing parameter validation anyway.)</p>
		<p>This is similar to what <a class="podlinkpod" href="https://metacpan.org/module/Moose">Moose</a> does when you run:</p>
		<pre class="highlighting-perl">        <span class="word">__PACKAGE__</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">meta</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">make_immutable</span><span class="structure">;</span></pre>
		<p>... and it's used all over the place within the Type-Tiny distribution.</p>
		<h2><span id="What_else_should_I_know?">What else should I know?</span></h2>
		<p>Type::Params is not a drop-in replacement for Params::Validate. Their features overlap, but are not identical.</p>
		<p>Params::Validate allows you to supply defaults for missing parameters; Type::Params does not. Params::Validate has a more natural interface for validating named parameters than Type::Params (though Type::Params can still do this). Each of them currently require Perl 5.8.1 or above, but CPAN still has old versions of Params::Validate available for Perl 5.5.</p>
		<p>Type::Params automatically does coercion (including "deep coercions") if your type constraint has coercions defined:</p>
		<pre class="highlighting-perl">        <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Type::Params</span> <span class="words" style="color:#333;background-color:#ffc">qw(compile)</span><span class="structure">;</span>
        <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Type::Utils</span> <span class="words" style="color:#333;background-color:#ffc">qw(declare as coerce from via)</span><span class="structure">;</span>
        <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Types::Standard</span> <span class="words" style="color:#333;background-color:#ffc">qw(:types slurpy)</span><span class="structure">;</span>
        
        <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="symbol" style="color:#333;background-color:#fcc">$Rounded</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">declare</span> <span class="word">as</span> <span class="word">Int</span><span class="structure">;</span>
        <span class="word">coerce</span> <span class="symbol" style="color:#333;background-color:#fcc">$Rounded</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">from</span> <span class="word">Num</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">via</span> <span class="structure">{</span> <span class="word">int</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">)</span> <span class="structure">};</span>
        
        <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="word">numbers</span> <span class="structure">{</span>
                <span class="word">state</span> <span class="symbol" style="color:#333;background-color:#fcc">$check</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">compile</span><span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$Rounded</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="word">slurpy</span> <span class="word">ArrayRef</span><span class="structure">[</span><span class="symbol" style="color:#333;background-color:#fcc">$Rounded</span><span class="structure">]);</span>
                <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$first</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$rest</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="symbol" style="color:#333;background-color:#fcc">$check</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">);</span>
                
<span class="comment" style="color:#060;font-style:italic">                # $first is 1
                # $rest is [2, 3]
</span>        <span class="structure">}</span>
        
        <span class="word">numbers</span><span class="structure">(</span><span class="float">1.1</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="float">2.2</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="float">3.3</span><span class="structure">);</span></pre>
		<p>But for me, ultimately the most compelling reason to use Type::Params is that it allows you to use the same library of type constraints for sub parameter validation that you already use for attributes in Moose/Moo/Mouse OO code.</p>
]]>
    </content>
</entry>
