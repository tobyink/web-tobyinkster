<?xml version="1.0" encoding="UTF-8"?>
<entry xmlns="http://www.w3.org/2005/Atom">
    <title>Exploring Type::Tiny Part 5: match_on_type</title>
    <link rel="alternate" type="text/html" href="http://blogs.perl.org/users/toby_inkster/2018/08/exploring-typetiny-part-5-match-on-type.html"/>
    <id>tag:blogs.perl.org,2018:/users/toby_inkster//1019.8880</id>

    <published>2018-08-19T18:18:22Z</published>
    <updated>2018-08-19T18:19:58Z</updated>

    <summary> Type::Tiny is probably best known as a way of having Moose-like type constraints in Moo, but it can be used for so much more. This is the fifth in a series of posts showing other things you can use...</summary>
    <author>
        <name>Toby Inkster</name>
        <uri>http://toby.ink/</uri>
    </author>
    
        <category term="Type-Tiny" scheme="http://www.sixapart.com/ns/types#category"/>
    
    <category term="typetiny" label="Type-Tiny" scheme="http://www.sixapart.com/ns/types#tag"/>
    
    <content type="html" xml:lang="en" xml:base="http://blogs.perl.org/users/toby_inkster/">
        <![CDATA[		<p><a class="podlinkpod" href="https://metacpan.org/pod/Type%3A%3ATiny">Type::Tiny</a> is probably best known as a way of having Moose-like type constraints in <a class="podlinkpod" href="https://metacpan.org/pod/Moo">Moo</a>, but it can be used for so much more. This is the fifth in a series of posts showing other things you can use Type::Tiny for. This article along with the earlier ones in the series can be found on <a class="podlinkurl" href="http://blogs.perl.org/users/toby_inkster/">my blog</a> and in the <a class="podlinkurl" href="https://www.perlmonks.org/?node=Cool%20Uses%20for%20Perl">Cool Uses for Perl section of PerlMonks</a>.</p>
		<p>It's pretty common to do things like this:</p>
		<pre class="highlighting-perl">   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Types::Standard</span> <span class="words" style="color:#333;background-color:#ffc">qw( is_ArrayRef is_HashRef )</span><span class="structure">;</span>
   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Carp</span> <span class="words" style="color:#333;background-color:#ffc">qw( croak )</span><span class="structure">;</span>
   
   <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="word">process_data</span> <span class="structure">{</span>
      <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">;</span>
      <span class="keyword" style="color:#009;font-weight:bold">if</span> <span class="structure">(</span><span class="word">is_ArrayRef</span><span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="structure">))</span> <span class="structure">{</span>
         <span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">_process_value</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">)</span> <span class="word">for</span> <span class="cast" style="color:#f00;font-weight:bold">@</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="structure">;</span>
      <span class="structure">}</span>
      <span class="keyword" style="color:#009;font-weight:bold">elsif</span> <span class="structure">(</span><span class="word">is_HashRef</span><span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="structure">))</span> <span class="structure">{</span>
         <span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">_process_value</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">)</span> <span class="word">for</span> <span class="word">values</span> <span class="cast" style="color:#f00;font-weight:bold">%</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="structure">;</span>
      <span class="structure">}</span>
      <span class="keyword" style="color:#009;font-weight:bold">else</span> <span class="structure">{</span>
         <span class="word">croak</span> <span class="double" style="color:#909">"Could not grok data"</span><span class="structure">;</span>
      <span class="structure">}</span>
   <span class="structure">}</span></pre>
		<p><a class="podlinkpod" href="https://metacpan.org/pod/Type%3A%3AUtils">Type::Utils</a> provides a perhaps slightly neater way to do this:</p>
]]>
        <![CDATA[		<pre class="highlighting-perl">   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Types::Standard</span> <span class="words" style="color:#333;background-color:#ffc">qw( ArrayRef HashRef Any )</span><span class="structure">;</span>
   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Type::Utils</span> <span class="words" style="color:#333;background-color:#ffc">qw( match_on_type )</span><span class="structure">;</span>
   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Carp</span> <span class="words" style="color:#333;background-color:#ffc">qw( croak )</span><span class="structure">;</span>
   
   <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="word">process_data</span> <span class="structure">{</span>
      <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">;</span>
      <span class="word">match_on_type</span> <span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="operator" style="color:#000;font-weight:bold">,</span>
         <span class="word">ArrayRef</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="structure">{</span> <span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">_process_value</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">)</span> <span class="word">for</span> <span class="cast" style="color:#f00;font-weight:bold">@</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span> <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span>
         <span class="word">HashRef</span><span class="operator" style="color:#000;font-weight:bold">,</span>  <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="structure">{</span> <span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">_process_value</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">)</span> <span class="word">for</span> <span class="word">values</span> <span class="cast" style="color:#f00;font-weight:bold">%</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span> <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span>
         <span class="word">Any</span><span class="operator" style="color:#000;font-weight:bold">,</span>      <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="structure">{</span> <span class="word">croak</span> <span class="double" style="color:#909">"Could not grok data"</span> <span class="structure">};</span>
   <span class="structure">}</span></pre>
		<p>The <code>match_on_type</code> function takes a value and a set of type–coderef pairs, dispatching to the first coderef where the value matches the type constraint. This function is stolen from <a class="podlinkpod" href="https://metacpan.org/pod/Moose%3A%3AUtil%3A%3ATypeConstraints">Moose::Util::TypeConstraints</a>.</p>
		<p>You can get an order of magnitude faster though by doing something similar to what <a class="podlinkpod" href="https://metacpan.org/pod/Type%3A%3AParams">Type::Params</a> does — compiling the match once, then calling it as needed.</p>
		<p>Let's look at a naïve (and wrong) way to do this first and examine the problems:</p>
		<pre class="highlighting-perl">   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Types::Standard</span> <span class="words" style="color:#333;background-color:#ffc">qw( ArrayRef HashRef Any )</span><span class="structure">;</span>
   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Type::Utils</span> <span class="words" style="color:#333;background-color:#ffc">qw( compile_match_on_type )</span><span class="structure">;</span>
   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Carp</span> <span class="words" style="color:#333;background-color:#ffc">qw( croak )</span><span class="structure">;</span>
   
   <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="word">process_data</span> <span class="structure">{</span>
      <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">;</span>
      <span class="word">state</span> <span class="symbol" style="color:#333;background-color:#fcc">$matcher</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">compile_match_on_type</span>
         <span class="word">ArrayRef</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="structure">{</span> <span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">_process_value</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">)</span> <span class="word">for</span> <span class="cast" style="color:#f00;font-weight:bold">@</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span> <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span>
         <span class="word">HashRef</span><span class="operator" style="color:#000;font-weight:bold">,</span>  <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="structure">{</span> <span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">_process_value</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">)</span> <span class="word">for</span> <span class="word">values</span> <span class="cast" style="color:#f00;font-weight:bold">%</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span> <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span>
         <span class="word">Any</span><span class="operator" style="color:#000;font-weight:bold">,</span>      <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="structure">{</span> <span class="word">croak</span> <span class="double" style="color:#909">"Could not grok data"</span> <span class="structure">};</span>
      <span class="symbol" style="color:#333;background-color:#fcc">$matcher</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="structure">);</span>
   <span class="structure">}</span></pre>
		<p>The big problem here is that the first time <code>process_data</code> is called, the matcher will <i>close over</i> <code>$self</code> and <code>$data</code>. Subsequent calls to <code>$matcher</code> will reuse the same closed over variables. Oops.</p>
		<p>The simplest way of solving this is to take advantage of the fact that a compiled matcher (unlike <code>match_on_type</code>) can take a list of arguments, not just one. Only the first argument is used for the type matching, but all arguments are passed to the coderefs on dispatch.</p>
		<pre class="highlighting-perl">   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Types::Standard</span> <span class="words" style="color:#333;background-color:#ffc">qw( ArrayRef HashRef Any )</span><span class="structure">;</span>
   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Type::Utils</span> <span class="words" style="color:#333;background-color:#ffc">qw( compile_match_on_type )</span><span class="structure">;</span>
   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Carp</span> <span class="words" style="color:#333;background-color:#ffc">qw( croak )</span><span class="structure">;</span>
   
   <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="word">process_data</span> <span class="structure">{</span>
      <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">;</span>
      <span class="word">state</span> <span class="symbol" style="color:#333;background-color:#fcc">$matcher</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">compile_match_on_type</span>
         <span class="word">ArrayRef</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="structure">{</span> <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$d</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$s</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">;</span> <span class="symbol" style="color:#333;background-color:#fcc">$s</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">_process_value</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">)</span> <span class="word">for</span> <span class="cast" style="color:#f00;font-weight:bold">@</span><span class="symbol" style="color:#333;background-color:#fcc">$d</span> <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span>
         <span class="word">HashRef</span><span class="operator" style="color:#000;font-weight:bold">,</span>  <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="structure">{</span> <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$d</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$s</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">;</span> <span class="symbol" style="color:#333;background-color:#fcc">$s</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="word">_process_value</span><span class="structure">(</span><span class="magic" style="color:#900;font-weight:bold">$_</span><span class="structure">)</span> <span class="word">for</span> <span class="word">values</span> <span class="cast" style="color:#f00;font-weight:bold">%</span><span class="symbol" style="color:#333;background-color:#fcc">$d</span> <span class="structure">}</span><span class="operator" style="color:#000;font-weight:bold">,</span>
         <span class="word">Any</span><span class="operator" style="color:#000;font-weight:bold">,</span>      <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="structure">{</span> <span class="word">croak</span> <span class="double" style="color:#909">"Could not grok data"</span> <span class="structure">};</span>
      <span class="symbol" style="color:#333;background-color:#fcc">$matcher</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="structure">);</span>
   <span class="structure">}</span></pre>
		<p>Like many Type::Tiny interfaces that expect coderefs, <code>compile_match_on_type</code> also accepts strings of Perl code as an alternative, and is able to optimize things better if those are supplied:</p>
		<pre class="highlighting-perl">   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Types::Standard</span> <span class="words" style="color:#333;background-color:#ffc">qw( ArrayRef HashRef Any )</span><span class="structure">;</span>
   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Type::Utils</span> <span class="words" style="color:#333;background-color:#ffc">qw( compile_match_on_type )</span><span class="structure">;</span>
   <span class="keyword" style="color:#009;font-weight:bold">use</span> <span class="word">Carp</span> <span class="words" style="color:#333;background-color:#ffc">qw()</span><span class="structure">;</span>
   
   <span class="keyword" style="color:#009;font-weight:bold">sub</span> <span class="word">process_data</span> <span class="structure">{</span>
      <span class="keyword" style="color:#009;font-weight:bold">my</span> <span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="structure">)</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="magic" style="color:#900;font-weight:bold">@_</span><span class="structure">;</span>
      <span class="word">state</span> <span class="symbol" style="color:#333;background-color:#fcc">$matcher</span> <span class="operator" style="color:#000;font-weight:bold">=</span> <span class="word">compile_match_on_type</span>
         <span class="word">ArrayRef</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="literal" style="color:#909">q{ my ($d, $s) = @_; $s-&gt;_process_value($_) for @$d }</span><span class="operator" style="color:#000;font-weight:bold">,</span>
         <span class="word">HashRef</span><span class="operator" style="color:#000;font-weight:bold">,</span>  <span class="literal" style="color:#909">q{ my ($d, $s) = @_; $s-&gt;_process_value($_) for values %$d }</span><span class="operator" style="color:#000;font-weight:bold">,</span>
         <span class="word">Any</span><span class="operator" style="color:#000;font-weight:bold">,</span>      <span class="literal" style="color:#909">q{ Carp::croak("Could not grok data") }</span><span class="structure">;</span>
      <span class="symbol" style="color:#333;background-color:#fcc">$matcher</span><span class="operator" style="color:#000;font-weight:bold">-&gt;</span><span class="structure">(</span><span class="symbol" style="color:#333;background-color:#fcc">$data</span><span class="operator" style="color:#000;font-weight:bold">,</span> <span class="symbol" style="color:#333;background-color:#fcc">$self</span><span class="structure">);</span>
   <span class="structure">}</span></pre>
		<p>The coderefs compiled by <code>compile_match_on_type</code> should be very efficient. The technique is very similar to how <a class="podlinkpod" href="https://metacpan.org/pod/Type%3A%3ACoercion">Type::Coercion</a> compiles coercions.</p>
]]>
    </content>
</entry>
